# design-model-note
Head First 设计模式学习代码

[TOC]

# 一、策略模式

> 策略模式定义了一个算法族，分别封装起来，使得他们之前可以互相变换。策略让算法的变换独立与使用他的客户。

## 1.设计原则

- 识别应用中变化的部分，把他们和不变的方面分开
- 针对接口编程，而不是针对实例编程
- 优先使用组合而不是继承

## 2.特点

- 具体算法从具体业务处理中独立
- 多个if-else出现时考虑使用策略模式
- 策略算法是形同行为的不同实现
- 客户端选择，上下文来具体实现策略算法

## 3.优点

- 避免让客户端涉及到重要算法和数据
- 避免使用难以维护的多重条件选择语句
- **容易管理和扩展**

## 4.缺点

- 判断逻辑在客户点，需求改变时，需要改变客户端的程序
- 客户端必须知道所有的策略类，然后自行选择，意味着客户端必须理解所有策略
- 增加了对象的数目
- 只适合扁平的算法结构



# 二、观察者模式

> 观察者模式定义了对象的一对多依赖，当一个对象改变状态时，所有依赖者都会收到通知并自动更新

## 1.松耦合

- 主题知道观察者的唯一一件事是，知道他实现了某个接口，并且知道这个接口
- 可以在任何时候添加观察者
- 如果需要添加观察者，绝对不能改变主题
- 可以彼此独立地复用主题或观察者
- 改变主题和观察者的一方，另一方不会收到影响

## 2.优点

- 观察者和被观察者是抽象耦合的
- 建立了一套触发机制

## 3.缺点

- 如果有很多个观察者，让所有观察者都得到结果会花费大量时间
- 如果观察者和主题之间存在循环依赖的话可能导致应用崩溃
- 观察者只知道数据变化了，不知道数据是怎么变化的

# 三、装饰者模式

> 动态地将额外责任附加到对象上。对于扩展功能，装饰者提供子类化之外的弹性替代方案

## 1.特点

- 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
- 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
- 装饰器模式完全遵守开闭原则

> 开闭原则：类应该对扩展开放，但对修改关闭

## 2.缺点

- 子类过多



# 单例模式

> 单例模式确保一个类只有一个实例，并提供一个全局访问点

## 1.特点

- 让一个类管理自己的单个实例，同时也避免其他类自行创建新实例
- 提供该实例的全局访问点，无论何时需要一个实例，只需要查询该类，它会交回单个实例

## 2.使用场景

- 在应用场景中，某类只要求生成一个对象的时候，如**一个班中的班长、每个人的身份证号**等。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的**配置对象、数据库的连接池**等。
- 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如**多线程的线程池、网络连接池**等。
